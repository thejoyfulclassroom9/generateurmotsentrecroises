<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur de Mots entrecrois√©s - Version Am√©lior√©e</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #000000;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        h1 {
            text-align: center;
            color: #000000;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .branding {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            padding: 15px;
            background: #ffffff;
            border-radius: 10px;
        }

        .logo {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 50%;
            border: 3px solid #000;
        }

        .branding-text {
            font-size: 0.95em;
            color: #555;
            font-weight: 500;
            margin: 0;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            font-family: Arial, sans-serif;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            min-height: 200px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }

        .help-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .color-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .color-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .color-option:hover {
            border-color: #000;
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .color-option input[type="radio"] {
            cursor: pointer;
        }

        .color-option input[type="radio"]:checked + .color-swatch {
            border: 3px solid #000;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #ccc;
            transition: all 0.3s;
        }

        .color-name {
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }

        .font-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .font-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .font-option:hover {
            border-color: #000;
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .font-option input[type="radio"] {
            cursor: pointer;
        }

        .font-option input[type="radio"]:checked ~ .font-preview {
            font-weight: bold;
            color: #000;
        }

        .font-preview {
            font-size: 16px;
            color: #555;
            transition: all 0.3s;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 200px;
        }

        .btn-primary {
            background: #000000;
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6);
        }

        .btn-success {
            background: #FA0F00;
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(250, 15, 0, 0.5);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-png {
            background: #FFD93D;
            color: #000;
            font-weight: bold;
        }

        .btn-png:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 217, 61, 0.5);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .preview-section {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 3px solid #f0f0f0;
        }

        .preview-section h2 {
            color: #000000;
            margin-bottom: 20px;
            text-align: center;
        }

        .grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            overflow-x: auto;
        }

        .crossword-grid {
            display: inline-grid;
            gap: 0;
            border: 2px solid #333;
            background: white;
        }

        .cell {
            width: 35px;
            height: 35px;
            border: 1px solid #999;
            position: relative;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        }

        .cell.black {
            background: white;
            border-color: white;
        }

        .cell-number {
            position: absolute;
            top: 3px;
            left: 4px;
            font-size: 9px;
            font-weight: bold;
            color: #000000;
        }

        .clues-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .clues-section {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
        }

        .clues-section h3 {
            color: #000000;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .clue-item {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .clue-number {
            font-weight: bold;
            color: #000000;
            margin-right: 5px;
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #c62828;
        }

        .success-message {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #2e7d32;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #000000;
            font-size: 1.2em;
        }

        @media print {
            body {
                background: white;
            }
            .input-section, .button-group {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .clues-container {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                min-width: 100%;
            }
            
            .color-options {
                grid-template-columns: 1fr;
            }
            
            .font-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß© G√©n√©rateur de Mots entrecrois√©s</h1>
        <p class="subtitle">Cr√©ez des mots entrecrois√©s professionnels en quelques clics!</p>
        
        <div class="branding">
            <img src="logo.png" alt="The Joyful Classroom" class="logo">
            <p class="branding-text">Offert gratuitement par <strong>The Joyful Classroom</strong></p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="title">Titre des mots entrecrois√©s :</label>
                <input type="text" id="title" placeholder="Ex: L'automne, Les animaux, etc." value="Mots entrecrois√©s">
            </div>

            <div class="input-group">
                <label>Couleur de la grille :</label>
                <div class="color-options">
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#FF6B6B" checked>
                        <span class="color-swatch" style="background: #FF6B6B;"></span>
                        <span class="color-name">Rouge corail</span>
                    </label>
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#FFA552">
                        <span class="color-swatch" style="background: #FFA552;"></span>
                        <span class="color-name">Orange doux</span>
                    </label>
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#FFD93D">
                        <span class="color-swatch" style="background: #FFD93D;"></span>
                        <span class="color-name">Jaune dor√©</span>
                    </label>
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#91C499">
                        <span class="color-swatch" style="background: #91C499;"></span>
                        <span class="color-name">Vert sauge</span>
                    </label>
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#2E8B57">
                        <span class="color-swatch" style="background: #2E8B57;"></span>
                        <span class="color-name">Vert for√™t</span>
                    </label>
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#4BA3C3">
                        <span class="color-swatch" style="background: #4BA3C3;"></span>
                        <span class="color-name">Bleu azur</span>
                    </label>
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#2C497F">
                        <span class="color-swatch" style="background: #2C497F;"></span>
                        <span class="color-name">Bleu profond</span>
                    </label>
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#000000">
                        <span class="color-swatch" style="background: #000000;"></span>
                        <span class="color-name">Noir total</span>
                    </label>
                    <label class="color-option">
                        <input type="radio" name="gridColor" value="#E056FD">
                        <span class="color-swatch" style="background: #E056FD;"></span>
                        <span class="color-name">Rose framboise</span>
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>Police de caract√®res (titre et indices) :</label>
                <div class="font-options">
                    <label class="font-option">
                        <input type="radio" name="fontFamily" value="Arial" checked>
                        <span class="font-preview" style="font-family: Arial;">Arial</span>
                    </label>
                    <label class="font-option">
                        <input type="radio" name="fontFamily" value="'Comic Sans MS'">
                        <span class="font-preview" style="font-family: 'Comic Sans MS';">Comic Sans MS</span>
                    </label>
                    <label class="font-option">
                        <input type="radio" name="fontFamily" value="Georgia">
                        <span class="font-preview" style="font-family: Georgia;">Georgia</span>
                    </label>
                    <label class="font-option">
                        <input type="radio" name="fontFamily" value="'Courier New'">
                        <span class="font-preview" style="font-family: 'Courier New';">Courier New</span>
                    </label>
                    <label class="font-option">
                        <input type="radio" name="fontFamily" value="Verdana">
                        <span class="font-preview" style="font-family: Verdana;">Verdana</span>
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label for="words">Mots et indices :</label>
                <textarea id="words" placeholder="Entrez un mot, un espace, puis l'indice. Un par ligne.&#10;Exemple:&#10;CHAT Animal domestique qui miaule&#10;CHIEN Meilleur ami de l'homme"></textarea>
                <p class="help-text">üí° Format: MOT Indice (un espace entre le mot et l'indice, un mot par ligne)</p>
            </div>

            <div class="button-group">
                <button class="btn-primary" onclick="generateCrossword()">G√©n√©rer les mots entrecrois√©s ‚úÖ</button>
                <button class="btn-primary" onclick="loadExample()">Charger l'exemple de "L'automne" üçÅ</button>
            </div>
        </div>

        <div id="message"></div>

        <div id="preview" class="preview-section" style="display: none;">
            <h2>üìÑ Aper√ßu</h2>
            <div id="crosswordDisplay"></div>
            
            <div class="button-group">
                <button class="btn-success" onclick="downloadPDF()">üì• T√©l√©charger en PDF</button>
                <button class="btn-success" onclick="downloadPDFWithAnswers()">üì• PDF avec corrig√©</button>
                <button class="btn-png" onclick="downloadPNG()">üñºÔ∏è T√©l√©charger en PNG</button>
            </div>
        </div>
    </div>

    <script>
        let currentCrossword = null;

        function getSelectedGridColor() {
            const selected = document.querySelector('input[name="gridColor"]:checked');
            return selected ? selected.value : '#FF6B6B';
        }

        function getSelectedFont() {
            const selected = document.querySelector('input[name="fontFamily"]:checked');
            return selected ? selected.value : 'Arial';
        }

        // Appliquer la police au titre principal quand elle change
        document.addEventListener('DOMContentLoaded', function() {
            const fontRadios = document.querySelectorAll('input[name="fontFamily"]');
            const mainTitle = document.querySelector('h1');
            
            fontRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    mainTitle.style.fontFamily = getSelectedFont();
                });
            });
        });

        function loadExample() {
            const exampleText = `CHRYSANTH√àME Fleur aux nombreux p√©tales qui fleurit en automne
CHAMPIGNON Il pousse dans les for√™ts humides apr√®s la pluie
FEUILLAGE Ensemble des feuilles d'un arbre qui change de couleur
BERNACHE Oie sauvage du Canada qui vole en formation en V
ORANG√â Couleur chaude qu'on voit partout dans la nature automnale
MA√èS C√©r√©ale jaune qu'on mange en √©pi lors des f√™tes d'automne
CITROUILLE Ce cucurbitac√©e orange devient une lanterne terrifiante
MIGRATION Long voyage que font les oies vers le sud quand il fait froid
√âQUINOXE Jour o√π la nuit et le jour ont exactement la m√™me dur√©e
√âCUREUIL Petit rongeur roux qui amasse des provisions pour l'hiver
OCTOBRE Mois o√π on c√©l√®bre l'Halloween et o√π les feuilles tombent le plus
R√âCOLTE Action de ramasser les fruits et l√©gumes m√ªrs dans les champs
√âRABLE Arbre embl√®me du Canada dont la s√®ve devient du sirop
VERGER Endroit o√π poussent les pommiers et o√π on cueille des fruits
VENT Il souffle plus fort en automne et fait danser les feuilles`;
            
            document.getElementById('words').value = exampleText;
            document.getElementById('title').value = "L'automne";
            showMessage("Exemple charg√©! Cliquez sur 'G√©n√©rer les mots entrecrois√©s'", "success");
        }

        function parseInput(text) {
            const lines = text.trim().split('\n').filter(line => line.trim());
            const words = [];
            
            for (let line of lines) {
                const match = line.match(/^([A-Z√Ä-√ø]+)\s+(.+)$/i);
                if (match) {
                    words.push({
                        word: match[1].toUpperCase().normalize("NFD").replace(/[\u0300-\u036f]/g, ""),
                        clue: match[2].trim(),
                        originalWord: match[1].toUpperCase()
                    });
                }
            }
            
            return words;
        }

        function showMessage(text, type = "error") {
            const messageDiv = document.getElementById('message');
            messageDiv.className = type === "success" ? "success-message" : "error-message";
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 5000);
        }

        class CrosswordGenerator {
            constructor(words) {
                this.words = words;
                this.grid = [];
                this.gridSize = 90; // Grille ENCORE plus grande (de 70 √† 90)
                this.placedWords = [];
            }

            generate() {
                let bestResult = null;
                let maxPlaced = 0;

                // MODE ULTRA ROBUSTE: Essayer 100 fois avec diff√©rentes strat√©gies
                for (let attempt = 0; attempt < 100; attempt++) {
                    this.initGrid();
                    this.placedWords = [];
                    
                    // Afficher la progression tous les 10 essais
                    if (attempt % 10 === 0 && attempt > 0) {
                        let strategy = '';
                        if (attempt < 25) strategy = 'LONGUEUR';
                        else if (attempt < 50) strategy = 'VOYELLES';
                        else if (attempt < 75) strategy = 'LETTRES COMMUNES';
                        else strategy = 'AL√âATOIRE';
                        
                        const progressMsg = `‚è≥ Strat√©gie ${strategy}: ${attempt}/100... Meilleur: ${maxPlaced}/${this.words.length} mots`;
                        document.getElementById('message').textContent = progressMsg;
                    }
                    
                    if (this.words.length === 0) return null;
                    
                    // üéØ STRAT√âGIE MULTI-APPROCHE: 4 m√©thodes diff√©rentes!
                    let wordsToPlace;
                    
                    if (attempt < 25) {
                        // Strat√©gie 1: Tri par LONGUEUR (mots longs d'abord)
                        wordsToPlace = [...this.words].sort((a, b) => b.word.length - a.word.length);
                    } else if (attempt < 50) {
                        // Strat√©gie 2: Tri par NOMBRE DE VOYELLES (plus de voyelles = plus facile √† connecter)
                        wordsToPlace = [...this.words].sort((a, b) => {
                            const vowelsA = (a.word.match(/[AEIOUY]/g) || []).length;
                            const vowelsB = (b.word.match(/[AEIOUY]/g) || []).length;
                            return vowelsB - vowelsA;
                        });
                    } else if (attempt < 75) {
                        // Strat√©gie 3: Tri par LETTRES COMMUNES (E, A, I, S, T, N, R)
                        wordsToPlace = [...this.words].sort((a, b) => {
                            const commonA = (a.word.match(/[EAISTNR]/g) || []).length;
                            const commonB = (b.word.match(/[EAISTNR]/g) || []).length;
                            return commonB - commonA;
                        });
                    } else {
                        // Strat√©gie 4: COMPL√àTEMENT AL√âATOIRE
                        wordsToPlace = this.shuffleArray([...this.words]);
                    }
                    
                    // Place le premier mot avec MAXIMUM de variation
                    const firstWord = wordsToPlace[0];
                    
                    // Alterner orientation toutes les 2 tentatives (plus de vari√©t√©)
                    const horizontal = attempt % 2 === 0;
                    
                    // VARIATION MASSIVE de position: explorer toute la grille!
                    // Au lieu de juste autour du centre, essayer 20 positions diff√©rentes
                    const positionVariant = attempt % 20;
                    let startRow, startCol;
                    
                    if (positionVariant < 5) {
                        // Centre avec petites variations
                        const offset = (positionVariant - 2) * 3;
                        startRow = Math.floor(this.gridSize / 2) + offset;
                        startCol = Math.floor((this.gridSize - firstWord.word.length) / 2) + offset;
                    } else if (positionVariant < 10) {
                        // Quart sup√©rieur gauche
                        startRow = Math.floor(this.gridSize / 4) + (positionVariant - 5) * 2;
                        startCol = Math.floor(this.gridSize / 4) + (positionVariant - 5) * 2;
                    } else if (positionVariant < 15) {
                        // Quart sup√©rieur droit
                        startRow = Math.floor(this.gridSize / 4) + (positionVariant - 10) * 2;
                        startCol = Math.floor(3 * this.gridSize / 4) - firstWord.word.length + (positionVariant - 10) * 2;
                    } else {
                        // Autres positions al√©atoires
                        const randomOffset = (positionVariant - 15) * 5;
                        startRow = Math.floor(this.gridSize / 3) + randomOffset;
                        startCol = Math.floor(this.gridSize / 3) + randomOffset;
                    }
                    
                    this.placeWord(firstWord, startRow, startCol, horizontal);
                    
                    // Essayer de placer les mots restants
                    for (let i = 1; i < wordsToPlace.length; i++) {
                        let placed = false;
                        
                        // MODE ULTRA ROBUSTE: Essayer jusqu'√† 1000 positions diff√©rentes
                        for (let tryCount = 0; tryCount < 1000 && !placed; tryCount++) {
                            placed = this.findAndPlaceWord(wordsToPlace[i]);
                        }
                        
                        if (!placed) {
                            console.warn(`Tentative ${attempt}: Impossible de placer "${wordsToPlace[i].word}"`);
                        }
                    }
                    
                    // Garder le meilleur r√©sultat
                    if (this.placedWords.length > maxPlaced) {
                        maxPlaced = this.placedWords.length;
                        this.trimGrid();
                        this.renumberWords();
                        
                        bestResult = {
                            grid: JSON.parse(JSON.stringify(this.grid)),
                            words: JSON.parse(JSON.stringify(this.placedWords)),
                            across: this.placedWords.filter(w => w.horizontal).sort((a, b) => a.number - b.number),
                            down: this.placedWords.filter(w => !w.horizontal).sort((a, b) => a.number - b.number)
                        };
                    }
                    
                    // Si tous les mots sont plac√©s, arr√™ter
                    if (this.placedWords.length === this.words.length) {
                        console.log(`Succ√®s √† la tentative ${attempt + 1}!`);
                        break;
                    }
                }
                
                return bestResult;
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            initGrid() {
                this.grid = Array(this.gridSize).fill(null).map(() => 
                    Array(this.gridSize).fill(null).map(() => ({ letter: null, number: null }))
                );
            }

            placeWord(wordObj, row, col, horizontal) {
                const word = wordObj.word;
                
                for (let i = 0; i < word.length; i++) {
                    const r = horizontal ? row : row + i;
                    const c = horizontal ? col + i : col;
                    this.grid[r][c].letter = word[i];
                }

                this.placedWords.push({
                    word: wordObj.originalWord,
                    clue: wordObj.clue,
                    row: row,
                    col: col,
                    horizontal: horizontal,
                    number: 0,
                    length: word.length
                });
                
                return true;
            }

            findAndPlaceWord(wordObj) {
                const word = wordObj.word;
                const possiblePlacements = [];

                // Chercher toutes les intersections possibles
                for (let placedWord of this.placedWords) {
                    const placedWordStr = placedWord.word.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
                    
                    // Pour chaque lettre du nouveau mot
                    for (let i = 0; i < word.length; i++) {
                        // Chercher cette lettre dans les mots d√©j√† plac√©s
                        for (let j = 0; j < placedWordStr.length; j++) {
                            if (word[i] === placedWordStr[j]) {
                                let newRow, newCol, horizontal;

                                // Calculer la position et l'orientation
                                if (placedWord.horizontal) {
                                    // Mot plac√© horizontal -> nouveau mot vertical
                                    horizontal = false;
                                    newRow = placedWord.row - i;
                                    newCol = placedWord.col + j;
                                } else {
                                    // Mot plac√© vertical -> nouveau mot horizontal
                                    horizontal = true;
                                    newRow = placedWord.row + j;
                                    newCol = placedWord.col - i;
                                }

                                // V√©rifier si le placement est valide
                                if (this.canPlaceWord(word, newRow, newCol, horizontal)) {
                                    const score = this.scorePosition(word, newRow, newCol, horizontal);
                                    possiblePlacements.push({
                                        row: newRow,
                                        col: newCol,
                                        horizontal: horizontal,
                                        score: score
                                    });
                                }
                            }
                        }
                    }
                }

                // Si on a trouv√© au moins une position valide
                if (possiblePlacements.length > 0) {
                    // Trier par score (nombre d'intersections)
                    possiblePlacements.sort((a, b) => b.score - a.score);
                    
                    // Prendre une des meilleures positions (MAXIMUM de vari√©t√©)
                    const topCount = Math.min(15, possiblePlacements.length);
                    const randomIndex = Math.floor(Math.random() * topCount);
                    const best = possiblePlacements[randomIndex];
                    
                    this.placeWord(wordObj, best.row, best.col, best.horizontal);
                    return true;
                }

                return false;
            }

            canPlaceWord(word, row, col, horizontal) {
                // V√©rifier les limites
                if (row < 1 || col < 1) return false;
                
                const endRow = horizontal ? row : row + word.length - 1;
                const endCol = horizontal ? col + word.length - 1 : col;
                
                if (endRow >= this.gridSize - 1 || endCol >= this.gridSize - 1) return false;

                let hasIntersection = false;

                // V√©rifier chaque position du mot
                for (let i = 0; i < word.length; i++) {
                    const r = horizontal ? row : row + i;
                    const c = horizontal ? col + i : col;
                    const cell = this.grid[r][c].letter;
                    
                    if (cell !== null) {
                        // Il y a d√©j√† une lettre ici
                        if (cell !== word[i]) {
                            // Lettre diff√©rente -> conflit
                            return false;
                        }
                        // M√™me lettre -> intersection valide
                        hasIntersection = true;
                    } else {
                        // Cellule vide -> v√©rifier les cellules adjacentes perpendiculaires
                        if (horizontal) {
                            // V√©rifier au-dessus et en-dessous
                            if (this.grid[r - 1][c].letter !== null || this.grid[r + 1][c].letter !== null) {
                                return false;
                            }
                        } else {
                            // V√©rifier √† gauche et √† droite
                            if (this.grid[r][c - 1].letter !== null || this.grid[r][c + 1].letter !== null) {
                                return false;
                            }
                        }
                    }
                }

                // V√©rifier les cases avant et apr√®s le mot
                if (horizontal) {
                    if (col > 0 && this.grid[row][col - 1].letter !== null) return false;
                    if (endCol < this.gridSize - 1 && this.grid[row][endCol + 1].letter !== null) return false;
                } else {
                    if (row > 0 && this.grid[row - 1][col].letter !== null) return false;
                    if (endRow < this.gridSize - 1 && this.grid[endRow + 1][col].letter !== null) return false;
                }

                // Pour le premier mot, on accepte sans intersection
                // Pour les autres, il faut au moins une intersection
                return this.placedWords.length === 0 || hasIntersection;
            }

            scorePosition(word, row, col, horizontal) {
                let score = 0;
                let intersections = 0;
                
                // Compter le nombre d'intersections
                for (let i = 0; i < word.length; i++) {
                    const r = horizontal ? row : row + i;
                    const c = horizontal ? col + i : col;
                    
                    if (this.grid[r][c].letter === word[i]) {
                        intersections++;
                        score += 25; // Bonus ENCORE plus √©lev√© (de 20 √† 25)
                        
                        // BONUS EXTRA pour les lettres rares (Q, X, Z, W, K, Y)
                        if ('QXZWKY'.includes(word[i])) {
                            score += 15; // Lettres rares valent plus!
                        }
                    }
                }
                
                // Bonus √âNORME pour les mots avec plusieurs intersections
                if (intersections > 1) {
                    score += intersections * 20; // Bonus exponentiel MASSIF (de 10 √† 20)
                }
                
                // P√âNALIT√â si le mot n'a qu'une seule intersection (on veut des grilles denses)
                if (intersections === 1) {
                    score -= 5;
                }
                
                // Bonus pour les positions plus centrales (mais moins important)
                const centerRow = this.gridSize / 2;
                const centerCol = this.gridSize / 2;
                const distanceFromCenter = Math.abs(row - centerRow) + Math.abs(col - centerCol);
                score -= distanceFromCenter * 0.01; // P√©nalit√© minimale
                
                return score;
            }

            trimGrid() {
                let minRow = this.gridSize, maxRow = 0;
                let minCol = this.gridSize, maxCol = 0;

                // Trouver les limites de la grille utilis√©e
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        if (this.grid[i][j].letter !== null) {
                            minRow = Math.min(minRow, i);
                            maxRow = Math.max(maxRow, i);
                            minCol = Math.min(minCol, j);
                            maxCol = Math.max(maxCol, j);
                        }
                    }
                }

                // Ajouter une marge d'une cellule
                minRow = Math.max(0, minRow - 1);
                maxRow = Math.min(this.gridSize - 1, maxRow + 1);
                minCol = Math.max(0, minCol - 1);
                maxCol = Math.min(this.gridSize - 1, maxCol + 1);

                // Cr√©er la nouvelle grille r√©duite
                const newGrid = [];
                for (let i = minRow; i <= maxRow; i++) {
                    newGrid.push(this.grid[i].slice(minCol, maxCol + 1));
                }

                // Ajuster les positions des mots
                for (let word of this.placedWords) {
                    word.row -= minRow;
                    word.col -= minCol;
                }

                this.grid = newGrid;
            }

            renumberWords() {
                const positions = [];
                
                // Regrouper les mots par position de d√©part
                for (let word of this.placedWords) {
                    const key = `${word.row}-${word.col}`;
                    const existing = positions.find(p => p.key === key);
                    
                    if (!existing) {
                        positions.push({
                            key: key,
                            row: word.row,
                            col: word.col,
                            words: [word]
                        });
                    } else {
                        existing.words.push(word);
                    }
                }

                // Trier par position (ligne puis colonne)
                positions.sort((a, b) => {
                    if (a.row !== b.row) return a.row - b.row;
                    return a.col - b.col;
                });

                // Attribuer les num√©ros
                for (let i = 0; i < positions.length; i++) {
                    const pos = positions[i];
                    for (let word of pos.words) {
                        word.number = i + 1;
                    }
                    this.grid[pos.row][pos.col].number = i + 1;
                }
            }
        }

        function generateCrossword() {
            const wordsText = document.getElementById('words').value;
            const title = document.getElementById('title').value || "Mots Crois√©s";

            if (!wordsText.trim()) {
                showMessage("Veuillez entrer des mots et leurs indices!");
                return;
            }

            const words = parseInput(wordsText);

            if (words.length === 0) {
                showMessage("Aucun mot valide trouv√©. V√©rifiez le format (MOT Indice)");
                return;
            }

            if (words.length < 2) {
                showMessage("Veuillez entrer au moins 2 mots pour cr√©er des mots entrecrois√©s");
                return;
            }

            // Afficher le chargement
            document.getElementById('message').className = 'loading';
            document.getElementById('message').textContent = '‚è≥ MODE ULTRA ROBUSTE - 4 STRAT√âGIES: L\'algorithme teste 100 configurations avec 4 approches diff√©rentes (longueur, voyelles, lettres communes, al√©atoire) - 30-90 sec';
            document.getElementById('message').style.display = 'block';

            setTimeout(() => {
                try {
                    const generator = new CrosswordGenerator(words);
                    currentCrossword = generator.generate();
                    currentCrossword.title = title;

                    if (currentCrossword && currentCrossword.words.length > 0) {
                        displayCrossword(currentCrossword);
                        document.getElementById('preview').style.display = 'block';
                        
                        const totalWords = words.length;
                        const placedWords = currentCrossword.words.length;
                        
                        if (placedWords < totalWords) {
                            const missingWords = words.filter(w => 
                                !currentCrossword.words.find(pw => 
                                    pw.word.normalize("NFD").replace(/[\u0300-\u036f]/g, "") === 
                                    w.word.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                                )
                            );
                            const missingList = missingWords.map(w => w.originalWord).join(', ');
                            showMessage(`‚ö†Ô∏è ${placedWords}/${totalWords} mots plac√©s apr√®s 100 tentatives. Mots non plac√©s: ${missingList}. Essayez de r√©g√©n√©rer ou de modifier l√©g√®rement vos mots.`, "error");
                        } else {
                            showMessage(`üéâ SUCC√àS! Tous les ${placedWords} mots ont √©t√© plac√©s!`, "success");
                        }
                        
                        // D√©filer vers l'aper√ßu
                        document.getElementById('preview').scrollIntoView({ behavior: 'smooth' });
                    } else {
                        showMessage("Erreur lors de la g√©n√©ration. Essayez avec d'autres mots.");
                    }
                } catch (error) {
                    showMessage("Erreur lors de la g√©n√©ration: " + error.message);
                    console.error(error);
                }
            }, 50); // Timeout r√©duit pour d√©marrer plus vite
        }

        function displayCrossword(crossword) {
            const display = document.getElementById('crosswordDisplay');
            display.innerHTML = '';

            // Cr√©er la grille
            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid-container';

            const gridDiv = document.createElement('div');
            gridDiv.className = 'crossword-grid';
            gridDiv.style.gridTemplateColumns = `repeat(${crossword.grid[0].length}, 35px)`;
            gridDiv.style.gridTemplateRows = `repeat(${crossword.grid.length}, 35px)`;
            
            const gridColor = getSelectedGridColor();

            for (let row of crossword.grid) {
                for (let cell of row) {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'cell';
                    
                    if (cell.letter === null) {
                        cellDiv.classList.add('black');
                    } else {
                        cellDiv.style.borderColor = gridColor;
                        if (cell.number) {
                            const numSpan = document.createElement('span');
                            numSpan.className = 'cell-number';
                            numSpan.textContent = cell.number;
                            cellDiv.appendChild(numSpan);
                        }
                    }
                    
                    gridDiv.appendChild(cellDiv);
                }
            }

            gridContainer.appendChild(gridDiv);
            display.appendChild(gridContainer);

            // Cr√©er les indices
            const cluesContainer = document.createElement('div');
            cluesContainer.className = 'clues-container';
            
            const selectedFont = getSelectedFont();

            // Indices horizontaux
            const acrossDiv = document.createElement('div');
            acrossDiv.className = 'clues-section';
            acrossDiv.style.fontFamily = selectedFont;
            acrossDiv.innerHTML = '<h3>Horizontal</h3>';
            crossword.across.forEach(word => {
                const clueDiv = document.createElement('div');
                clueDiv.className = 'clue-item';
                clueDiv.innerHTML = `<span class="clue-number">${word.number}.</span>${word.clue}`;
                acrossDiv.appendChild(clueDiv);
            });

            // Indices verticaux
            const downDiv = document.createElement('div');
            downDiv.className = 'clues-section';
            downDiv.style.fontFamily = selectedFont;
            downDiv.innerHTML = '<h3>Vertical</h3>';
            crossword.down.forEach(word => {
                const clueDiv = document.createElement('div');
                clueDiv.className = 'clue-item';
                clueDiv.innerHTML = `<span class="clue-number">${word.number}.</span>${word.clue}`;
                downDiv.appendChild(clueDiv);
            });

            cluesContainer.appendChild(acrossDiv);
            cluesContainer.appendChild(downDiv);
            display.appendChild(cluesContainer);
        }

        function downloadPDF(withAnswers = false) {
            if (!currentCrossword) {
                showMessage("Veuillez d'abord g√©n√©rer des mots entrecrois√©s!");
                return;
            }

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'letter'
                });

                const pageWidth = 215.9;
                const pageHeight = 279.4;
                const margin = 12;
                
                const gridColor = getSelectedGridColor();
                const selectedFont = getSelectedFont().replace(/'/g, ''); // Enlever les quotes

                // Titre en haut
                doc.setFontSize(22);
                doc.setFont(selectedFont, 'bold');
                doc.text(currentCrossword.title, pageWidth / 2, margin + 8, { align: 'center' });

                // Calculer les dimensions de la grille
                const grid = currentCrossword.grid;
                const rows = grid.length;
                const cols = grid[0].length;
                
                // Espace AUGMENT√â pour les indices en bas (60mm au lieu de 45mm)
                const cluesHeight = 60;
                
                // Maximiser l'espace pour la grille
                const availableWidth = pageWidth - 2 * margin;
                const maxGridHeight = pageHeight - margin - 28 - cluesHeight - 5;
                
                const cellSizeByWidth = availableWidth / cols;
                const cellSizeByHeight = maxGridHeight / rows;
                const cellSize = Math.min(cellSizeByWidth, cellSizeByHeight, 12); // R√©duit de 15 √† 12mm max
                
                const gridWidth = cellSize * cols;
                const gridHeight = cellSize * rows;
                const gridX = (pageWidth - gridWidth) / 2;
                const gridY = margin + 22;

                // Dessiner la grille
                doc.setLineWidth(0.4);
                
                // Convertir hex en RGB pour jsPDF
                const hexToRgb = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return { r, g, b };
                };
                
                const color = hexToRgb(gridColor);
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const x = gridX + j * cellSize;
                        const y = gridY + i * cellSize;
                        const cell = grid[i][j];

                        if (cell.letter === null) {
                            continue;
                        } else {
                            doc.setFillColor(255, 255, 255);
                            doc.setDrawColor(color.r, color.g, color.b);
                            doc.rect(x, y, cellSize, cellSize, 'FD');
                            
                            // Num√©ro (seulement si pas de r√©ponses)
                            if (cell.number && !withAnswers) {
                                doc.setFontSize(cellSize * 1.3);
                                doc.setFont(undefined, 'bold');
                                doc.setTextColor(0, 0, 0);
                                doc.text(cell.number.toString(), x + cellSize * 0.18, y + cellSize * 0.42);
                            }

                            // Lettre (si avec r√©ponses)
                            if (withAnswers && cell.letter) {
                                doc.setFontSize(cellSize * 2.5);
                                doc.setFont(undefined, 'bold');
                                doc.setTextColor(0, 0, 0);
                                doc.text(cell.letter, x + cellSize / 2, y + cellSize * 0.73, { align: 'center' }); // Centrage vertical optimal
                            }
                        }
                    }
                }

                // Ajouter les num√©ros √† l'ext√©rieur des cases pour le corrig√©
                if (withAnswers) {
                    doc.setFontSize(cellSize * 1.2);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(0, 0, 0);
                    
                    currentCrossword.words.forEach(word => {
                        const x = gridX + word.col * cellSize;
                        const y = gridY + word.row * cellSize;
                        
                        if (word.horizontal) {
                            // Pour les mots horizontaux: num√©ro √† gauche
                            doc.text(word.number.toString(), x - cellSize * 0.6, y + cellSize * 0.65);
                        } else {
                            // Pour les mots verticaux: num√©ro en haut
                            doc.text(word.number.toString(), x + cellSize * 0.3, y - cellSize * 0.15);
                        }
                    });
                }

                // Indices en bas de page
                const cluesY = pageHeight - cluesHeight - margin + 2;
                const columnWidth = (pageWidth - 2 * margin - 5) / 2;

                doc.setTextColor(0, 0, 0);
                doc.setFontSize(10); // Police plus grosse pour les titres
                doc.setFont(selectedFont, 'bold');
                doc.text('Horizontal', margin, cluesY);
                doc.text('Vertical', margin + columnWidth + 5, cluesY);

                doc.setFontSize(10.5); // Police plus grosse pour les indices
                doc.setFont(selectedFont, 'normal');

                let acrossY = cluesY + 7; // Plus d'espace apr√®s le titre
                let downY = cluesY + 7; // Plus d'espace apr√®s le titre
                const lineHeight = 5.4; // Ajust√© pour la police plus grosse (10.5)
                const maxClueWidth = columnWidth - 2;

                // Indices horizontaux - TOUJOURS afficher tous les indices
                currentCrossword.across.forEach(word => {
                    const clueText = `${word.number}. ${word.clue}`;
                    const lines = doc.splitTextToSize(clueText, maxClueWidth);
                    
                    doc.text(lines, margin, acrossY);
                    acrossY += lines.length * lineHeight;
                });

                // Indices verticaux - TOUJOURS afficher tous les indices
                currentCrossword.down.forEach(word => {
                    const clueText = `${word.number}. ${word.clue}`;
                    const lines = doc.splitTextToSize(clueText, maxClueWidth);
                    
                    doc.text(lines, margin + columnWidth + 5, downY);
                    downY += lines.length * lineHeight;
                });

                // Copyright en bas √† droite (positionn√© au-dessus de la marge)
                doc.setFontSize(6);
                doc.setFont(undefined, 'normal');
                doc.setTextColor(100, 100, 100);
                doc.text('¬© The Joyful Classroom', pageWidth - margin, pageHeight - 3, { align: 'right' });

                // Sauvegarder
                const filename = withAnswers ? 
                    `${currentCrossword.title}_corrige.pdf` : 
                    `${currentCrossword.title}.pdf`;
                doc.save(filename);

                showMessage(`‚úÖ PDF t√©l√©charg√©: ${filename}`, "success");
            } catch (error) {
                showMessage("Erreur lors de la cr√©ation du PDF: " + error.message);
                console.error(error);
            }
        }

        function downloadPDFWithAnswers() {
            downloadPDF(true);
        }

        function downloadPNG() {
            if (!currentCrossword) {
                showMessage("Veuillez d'abord g√©n√©rer des mots entrecrois√©s!");
                return;
            }

            try {
                const canvas = document.createElement('canvas');
                const width = 2550;
                const height = 3300;
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // Fond blanc
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);

                const margin = 100;

                const selectedFont = getSelectedFont().replace(/'/g, ''); // Enlever les quotes

                // Titre
                ctx.fillStyle = '#000000';
                ctx.font = `bold 80px ${selectedFont}`;
                ctx.textAlign = 'center';
                ctx.fillText(currentCrossword.title, width / 2, margin + 80);

                // Calculer les dimensions de la grille
                const grid = currentCrossword.grid;
                const rows = grid.length;
                const cols = grid[0].length;

                const cluesHeight = 700; // Augment√© de 580 √† 700 pour plus d'espace pour les indices
                const availableWidth = width - 2 * margin;
                const maxGridHeight = height - margin - 200 - cluesHeight - 20;
                
                const cellSizeByWidth = availableWidth / cols;
                const cellSizeByHeight = maxGridHeight / rows;
                const cellSize = Math.min(cellSizeByWidth, cellSizeByHeight, 130); // R√©duit de 150 √† 130
                
                const gridWidth = cellSize * cols;
                const gridHeight = cellSize * rows;
                const gridX = (width - gridWidth) / 2;
                const gridY = margin + 180;

                // Dessiner la grille
                const gridColor = getSelectedGridColor();
                ctx.lineWidth = 3;
                ctx.strokeStyle = gridColor;

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const x = gridX + j * cellSize;
                        const y = gridY + i * cellSize;
                        const cell = grid[i][j];

                        if (cell.letter !== null) {
                            ctx.strokeRect(x, y, cellSize, cellSize);
                            
                            if (cell.number) {
                                ctx.fillStyle = '#000000';
                                ctx.font = `bold ${cellSize * 0.28}px Arial`;
                                ctx.textAlign = 'left';
                                ctx.fillText(cell.number.toString(), x + cellSize * 0.12, y + cellSize * 0.32);
                            }
                        }
                    }
                }

                // Dessiner les indices TOUT EN BAS
                const cluesY = height - cluesHeight - margin + 50; // Plus pr√®s du bas
                const columnWidth = (width - 2 * margin - 60) / 2;

                ctx.fillStyle = '#000000';
                ctx.font = `bold 44px ${selectedFont}`;
                ctx.textAlign = 'left';
                ctx.fillText('Horizontal', margin, cluesY);
                ctx.fillText('Vertical', margin + columnWidth + 60, cluesY);

                ctx.font = `32px ${selectedFont}`;
                let acrossY = cluesY + 55; // Plus d'espace apr√®s le titre
                let downY = cluesY + 55; // Plus d'espace apr√®s le titre
                const lineHeight = 47; // Ajust√© pour la police plus grosse (32px)

                function wrapText(text, maxWidth) {
                    const words = text.split(' ');
                    const lines = [];
                    let currentLine = words[0];

                    for (let i = 1; i < words.length; i++) {
                        const testLine = currentLine + ' ' + words[i];
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth) {
                            lines.push(currentLine);
                            currentLine = words[i];
                        } else {
                            currentLine = testLine;
                        }
                    }
                    lines.push(currentLine);
                    return lines;
                }

                // Indices horizontaux - TOUJOURS afficher tous les indices
                currentCrossword.across.forEach(word => {
                    const clueText = `${word.number}. ${word.clue}`;
                    const lines = wrapText(clueText, columnWidth - 20);
                    
                    lines.forEach(line => {
                        ctx.fillText(line, margin, acrossY);
                        acrossY += lineHeight;
                    });
                });

                // Indices verticaux - TOUJOURS afficher tous les indices
                currentCrossword.down.forEach(word => {
                    const clueText = `${word.number}. ${word.clue}`;
                    const lines = wrapText(clueText, columnWidth - 20);
                    
                    lines.forEach(line => {
                        ctx.fillText(line, margin + columnWidth + 60, downY);
                        downY += lineHeight;
                    });
                });

                // Copyright en bas √† droite (positionn√© au-dessus de la marge)
                ctx.fillStyle = '#666666';
                ctx.font = '20px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('¬© The Joyful Classroom', width - margin, height - 30);

                // Convertir en PNG et t√©l√©charger
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${currentCrossword.title}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showMessage(`‚úÖ PNG t√©l√©charg√©: ${currentCrossword.title}.png`, "success");
                }, 'image/png');

            } catch (error) {
                showMessage("Erreur lors de la cr√©ation du PNG: " + error.message);
                console.error(error);
            }
        }
    </script>
</body>
</html>
