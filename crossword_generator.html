<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur de Mots entrecrois√©s</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            font-family: Arial, sans-serif;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            min-height: 200px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }

        .help-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 200px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .preview-section {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 3px solid #f0f0f0;
        }

        .preview-section h2 {
            color: #667eea;
            margin-bottom: 20px;
            text-align: center;
        }

        .grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            overflow-x: auto;
        }

        .crossword-grid {
            display: inline-grid;
            gap: 0;
            border: 2px solid #333;
            background: white;
        }

        .cell {
            width: 35px;
            height: 35px;
            border: 1px solid #999;
            position: relative;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        }

        .cell.black {
            background: white;
            border-color: white;
        }

        .cell-number {
            position: absolute;
            top: 3px;
            left: 4px;
            font-size: 9px;
            font-weight: bold;
            color: #667eea;
        }

        .clues-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .clues-section {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
        }

        .clues-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .clue-item {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .clue-number {
            font-weight: bold;
            color: #667eea;
            margin-right: 5px;
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #c62828;
        }

        .success-message {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #2e7d32;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-size: 1.2em;
        }

        @media print {
            body {
                background: white;
            }
            .input-section, .button-group {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .clues-container {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß© G√©n√©rateur de Mots entrecrois√©s</h1>
        <p class="subtitle">Cr√©ez des mots entrecrois√©s professionnels en quelques clics!</p>

        <div class="input-section">
            <div class="input-group">
                <label for="title">Titre des mots entrecrois√©s :</label>
                <input type="text" id="title" placeholder="Ex: L'automne, Les animaux, etc." value="Mots entrecrois√©s">
            </div>

            <div class="input-group">
                <label for="words">Mots et indices :</label>
                <textarea id="words" placeholder="Entrez un mot, un espace, puis l'indice. Un par ligne.&#10;Exemple:&#10;CHAT Animal domestique qui miaule&#10;CHIEN Meilleur ami de l'homme"></textarea>
                <p class="help-text">üí° Format: MOT Indice (un espace entre le mot et l'indice, un mot par ligne)</p>
            </div>

            <div class="button-group">
                <button class="btn-primary" onclick="generateCrossword()">‚ú® G√©n√©rer les mots entrecrois√©s</button>
                <button class="btn-secondary" onclick="loadExample()">üìù Charger l'exemple automne</button>
            </div>
        </div>

        <div id="message"></div>

        <div id="preview" class="preview-section" style="display: none;">
            <h2>üìÑ Aper√ßu</h2>
            <div id="crosswordDisplay"></div>
            
            <div class="button-group">
                <button class="btn-success" onclick="downloadPDF()">üì• T√©l√©charger en PDF</button>
                <button class="btn-secondary" onclick="downloadPDFWithAnswers()">üì• PDF avec corrig√©</button>
                <button class="btn-success" onclick="downloadPNG()">üñºÔ∏è T√©l√©charger en PNG</button>
            </div>
        </div>
    </div>

    <script>
        let currentCrossword = null;

        function loadExample() {
            const exampleText = `CHRYSANTH√àME Fleur aux nombreux p√©tales qui fleurit en automne
CHAMPIGNON Il pousse dans les for√™ts humides apr√®s la pluie
FEUILLAGE Ensemble des feuilles d'un arbre qui change de couleur
BERNACHE Oie sauvage du Canada qui vole en formation en V
ORANG√â Couleur chaude qu'on voit partout dans la nature automnale
MA√èS C√©r√©ale jaune qu'on mange en √©pi lors des f√™tes d'automne
CITROUILLE Ce cucurbitac√©e orange devient une lanterne terrifiante
MIGRATION Long voyage que font les oies vers le sud quand il fait froid
√âQUINOXE Jour o√π la nuit et le jour ont exactement la m√™me dur√©e
√âCUREUIL Petit rongeur roux qui amasse des provisions pour l'hiver
OCTOBRE Mois o√π on c√©l√®bre l'Halloween et o√π les feuilles tombent le plus
R√âCOLTE Action de ramasser les fruits et l√©gumes m√ªrs dans les champs
√âRABLE Arbre embl√®me du Canada dont la s√®ve devient du sirop
VERGER Endroit o√π poussent les pommiers et o√π on cueille des fruits
VENT Il souffle plus fort en automne et fait danser les feuilles`;
            
            document.getElementById('words').value = exampleText;
            document.getElementById('title').value = "L'automne";
            showMessage("Exemple charg√©! Cliquez sur 'G√©n√©rer les mots entrecrois√©s'", "success");
        }

        function parseInput(text) {
            const lines = text.trim().split('\n').filter(line => line.trim());
            const words = [];
            
            for (let line of lines) {
                const match = line.match(/^([A-Z√Ä-√ø]+)\s+(.+)$/i);
                if (match) {
                    words.push({
                        word: match[1].toUpperCase().normalize("NFD").replace(/[\u0300-\u036f]/g, ""),
                        clue: match[2].trim(),
                        originalWord: match[1].toUpperCase()
                    });
                }
            }
            
            return words;
        }

        function showMessage(text, type = "error") {
            const messageDiv = document.getElementById('message');
            messageDiv.className = type === "success" ? "success-message" : "error-message";
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 5000);
        }

        class CrosswordGenerator {
            constructor(words) {
                this.words = words.sort((a, b) => b.word.length - a.word.length);
                this.grid = [];
                this.gridSize = 50;
                this.placedWords = [];
            }

            generate() {
                // Try multiple times to get best result
                let bestResult = null;
                let maxPlaced = 0;

                for (let attempt = 0; attempt < 5; attempt++) {
                    this.initGrid();
                    this.placedWords = [];
                    
                    if (this.words.length === 0) return null;
                    
                    // Place first word horizontally in center
                    const firstWord = this.words[0];
                    const startRow = Math.floor(this.gridSize / 2);
                    const startCol = Math.floor((this.gridSize - firstWord.word.length) / 2);
                    
                    this.placeWord(firstWord, startRow, startCol, true);
                    
                    // Try to place remaining words with multiple attempts per word
                    for (let i = 1; i < this.words.length; i++) {
                        let placed = false;
                        // Try up to 50 different positions for each word
                        for (let tryCount = 0; tryCount < 50 && !placed; tryCount++) {
                            placed = this.findAndPlaceWord(this.words[i]);
                        }
                        
                        if (!placed) {
                            console.warn(`Could not place word: ${this.words[i].word}`);
                        }
                    }
                    
                    if (this.placedWords.length > maxPlaced) {
                        maxPlaced = this.placedWords.length;
                        // Trim and renumber before saving
                        this.trimGrid();
                        this.renumberWords();
                        
                        bestResult = {
                            grid: JSON.parse(JSON.stringify(this.grid)),
                            words: JSON.parse(JSON.stringify(this.placedWords)),
                            across: this.placedWords.filter(w => w.horizontal).sort((a, b) => a.number - b.number),
                            down: this.placedWords.filter(w => !w.horizontal).sort((a, b) => a.number - b.number)
                        };
                    }
                    
                    // If all words placed, we're done
                    if (this.placedWords.length === this.words.length) {
                        break;
                    }
                }
                
                return bestResult;
            }

            initGrid() {
                this.grid = Array(this.gridSize).fill(null).map(() => 
                    Array(this.gridSize).fill(null).map(() => ({ letter: null, number: null }))
                );
            }

            placeWord(wordObj, row, col, horizontal) {
                const word = wordObj.word;
                const placement = {
                    word: wordObj.originalWord,
                    clue: wordObj.clue,
                    row: row,
                    col: col,
                    horizontal: horizontal,
                    number: 0,
                    length: word.length
                };

                for (let i = 0; i < word.length; i++) {
                    const r = horizontal ? row : row + i;
                    const c = horizontal ? col + i : col;
                    
                    if (this.grid[r][c].letter === null) {
                        this.grid[r][c].letter = word[i];
                    }
                }

                this.placedWords.push(placement);
                return true;
            }

            findAndPlaceWord(wordObj) {
                const word = wordObj.word;
                const possiblePlacements = [];

                // Find all possible intersections with placed words
                for (let placedWord of this.placedWords) {
                    const placedWordStr = placedWord.word.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
                    
                    for (let i = 0; i < word.length; i++) {
                        for (let j = 0; j < placedWordStr.length; j++) {
                            if (word[i] === placedWordStr[j]) {
                                let newRow, newCol, horizontal;

                                if (placedWord.horizontal) {
                                    horizontal = false;
                                    newRow = placedWord.row - i;
                                    newCol = placedWord.col + j;
                                } else {
                                    horizontal = true;
                                    newRow = placedWord.row + j;
                                    newCol = placedWord.col - i;
                                }

                                if (this.canPlaceWord(word, newRow, newCol, horizontal)) {
                                    possiblePlacements.push({
                                        row: newRow,
                                        col: newCol,
                                        horizontal: horizontal,
                                        score: this.scorePosition(word, newRow, newCol, horizontal)
                                    });
                                }
                            }
                        }
                    }
                }

                if (possiblePlacements.length > 0) {
                    possiblePlacements.sort((a, b) => b.score - a.score);
                    const best = possiblePlacements[0];
                    this.placeWord(wordObj, best.row, best.col, best.horizontal);
                    return true;
                }

                return false;
            }

            canPlaceWord(word, row, col, horizontal) {
                if (row < 1 || col < 1) return false;
                
                const endRow = horizontal ? row : row + word.length - 1;
                const endCol = horizontal ? col + word.length - 1 : col;
                
                if (endRow >= this.gridSize - 1 || endCol >= this.gridSize - 1) return false;

                // Check each cell
                for (let i = 0; i < word.length; i++) {
                    const r = horizontal ? row : row + i;
                    const c = horizontal ? col + i : col;

                    const cell = this.grid[r][c].letter;
                    
                    if (cell !== null && cell !== word[i]) {
                        return false;
                    }

                    // Check perpendicular cells (must be empty unless it's an intersection)
                    if (cell === null || cell !== word[i]) {
                        if (horizontal) {
                            if (this.grid[r - 1][c].letter !== null) return false;
                            if (this.grid[r + 1][c].letter !== null) return false;
                        } else {
                            if (this.grid[r][c - 1].letter !== null) return false;
                            if (this.grid[r][c + 1].letter !== null) return false;
                        }
                    }
                }

                // Check cells before and after word
                if (horizontal) {
                    if (col > 0 && this.grid[row][col - 1].letter !== null) return false;
                    if (endCol < this.gridSize - 1 && this.grid[row][endCol + 1].letter !== null) return false;
                } else {
                    if (row > 0 && this.grid[row - 1][col].letter !== null) return false;
                    if (endRow < this.gridSize - 1 && this.grid[endRow + 1][col].letter !== null) return false;
                }

                return true;
            }

            scorePosition(word, row, col, horizontal) {
                let score = 0;
                
                for (let i = 0; i < word.length; i++) {
                    const r = horizontal ? row : row + i;
                    const c = horizontal ? col + i : col;
                    
                    if (this.grid[r][c].letter === word[i]) {
                        score += 10;
                    }
                }
                
                return score;
            }

            trimGrid() {
                let minRow = this.gridSize, maxRow = 0;
                let minCol = this.gridSize, maxCol = 0;

                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        if (this.grid[i][j].letter !== null) {
                            minRow = Math.min(minRow, i);
                            maxRow = Math.max(maxRow, i);
                            minCol = Math.min(minCol, j);
                            maxCol = Math.max(maxCol, j);
                        }
                    }
                }

                minRow = Math.max(0, minRow - 1);
                maxRow = Math.min(this.gridSize - 1, maxRow + 1);
                minCol = Math.max(0, minCol - 1);
                maxCol = Math.min(this.gridSize - 1, maxCol + 1);

                const newGrid = [];
                for (let i = minRow; i <= maxRow; i++) {
                    newGrid.push(this.grid[i].slice(minCol, maxCol + 1));
                }

                for (let word of this.placedWords) {
                    word.row -= minRow;
                    word.col -= minCol;
                }

                this.grid = newGrid;
            }

            renumberWords() {
                const positions = [];
                
                for (let word of this.placedWords) {
                    const key = `${word.row}-${word.col}`;
                    const existing = positions.find(p => p.key === key);
                    
                    if (!existing) {
                        positions.push({
                            key: key,
                            row: word.row,
                            col: word.col,
                            words: [word]
                        });
                    } else {
                        existing.words.push(word);
                    }
                }

                positions.sort((a, b) => {
                    if (a.row !== b.row) return a.row - b.row;
                    return a.col - b.col;
                });

                for (let i = 0; i < positions.length; i++) {
                    const pos = positions[i];
                    for (let word of pos.words) {
                        word.number = i + 1;
                    }
                    
                    this.grid[pos.row][pos.col].number = i + 1;
                }
            }
        }

        function generateCrossword() {
            const wordsText = document.getElementById('words').value;
            const title = document.getElementById('title').value || "Mots Crois√©s";

            if (!wordsText.trim()) {
                showMessage("Veuillez entrer des mots et leurs indices!");
                return;
            }

            const words = parseInput(wordsText);

            if (words.length === 0) {
                showMessage("Aucun mot valide trouv√©. V√©rifiez le format (MOT Indice)");
                return;
            }

            if (words.length < 2) {
                showMessage("Veuillez entrer au moins 2 mots pour cr√©er des mots entrecrois√©s");
                return;
            }

            // Show loading
            document.getElementById('message').className = 'loading';
            document.getElementById('message').textContent = '‚è≥ G√©n√©ration en cours...';
            document.getElementById('message').style.display = 'block';

            setTimeout(() => {
                try {
                    const generator = new CrosswordGenerator(words);
                    currentCrossword = generator.generate();
                    currentCrossword.title = title;

                    if (currentCrossword && currentCrossword.words.length > 0) {
                        displayCrossword(currentCrossword);
                        document.getElementById('preview').style.display = 'block';
                        
                        const totalWords = words.length;
                        const placedWords = currentCrossword.words.length;
                        
                        if (placedWords < totalWords) {
                            showMessage(`‚ö†Ô∏è ${placedWords}/${totalWords} mots plac√©s. Certains mots n'ont pas pu √™tre plac√©s (essayez avec des mots diff√©rents ou moins de mots).`, "error");
                        } else {
                            showMessage(`‚úÖ ${placedWords} mots plac√©s avec succ√®s!`, "success");
                        }
                        
                        // Scroll to preview
                        document.getElementById('preview').scrollIntoView({ behavior: 'smooth' });
                    } else {
                        showMessage("Erreur lors de la g√©n√©ration. Essayez avec d'autres mots.");
                    }
                } catch (error) {
                    showMessage("Erreur lors de la g√©n√©ration: " + error.message);
                    console.error(error);
                }
            }, 100);
        }

        function displayCrossword(crossword) {
            const display = document.getElementById('crosswordDisplay');
            display.innerHTML = '';

            // Create grid
            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid-container';

            const gridDiv = document.createElement('div');
            gridDiv.className = 'crossword-grid';
            gridDiv.style.gridTemplateColumns = `repeat(${crossword.grid[0].length}, 35px)`;
            gridDiv.style.gridTemplateRows = `repeat(${crossword.grid.length}, 35px)`;

            for (let row of crossword.grid) {
                for (let cell of row) {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'cell';
                    
                    if (cell.letter === null) {
                        cellDiv.classList.add('black');
                    } else {
                        if (cell.number) {
                            const numSpan = document.createElement('span');
                            numSpan.className = 'cell-number';
                            numSpan.textContent = cell.number;
                            cellDiv.appendChild(numSpan);
                        }
                    }
                    
                    gridDiv.appendChild(cellDiv);
                }
            }

            gridContainer.appendChild(gridDiv);
            display.appendChild(gridContainer);

            // Create clues
            const cluesContainer = document.createElement('div');
            cluesContainer.className = 'clues-container';

            // Horizontal clues
            const acrossDiv = document.createElement('div');
            acrossDiv.className = 'clues-section';
            acrossDiv.innerHTML = '<h3>Horizontal</h3>';
            crossword.across.forEach(word => {
                const clueDiv = document.createElement('div');
                clueDiv.className = 'clue-item';
                clueDiv.innerHTML = `<span class="clue-number">${word.number}.</span>${word.clue}`;
                acrossDiv.appendChild(clueDiv);
            });

            // Vertical clues
            const downDiv = document.createElement('div');
            downDiv.className = 'clues-section';
            downDiv.innerHTML = '<h3>Vertical</h3>';
            crossword.down.forEach(word => {
                const clueDiv = document.createElement('div');
                clueDiv.className = 'clue-item';
                clueDiv.innerHTML = `<span class="clue-number">${word.number}.</span>${word.clue}`;
                downDiv.appendChild(clueDiv);
            });

            cluesContainer.appendChild(acrossDiv);
            cluesContainer.appendChild(downDiv);
            display.appendChild(cluesContainer);
        }

        function downloadPDF(withAnswers = false) {
            if (!currentCrossword) {
                showMessage("Veuillez d'abord g√©n√©rer des mots entrecrois√©s!");
                return;
            }

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'letter'
                });

                const pageWidth = 215.9;
                const pageHeight = 279.4;
                const margin = 12;

                // Title at top
                doc.setFontSize(22);
                doc.setFont(undefined, 'bold');
                doc.text(currentCrossword.title, pageWidth / 2, margin + 8, { align: 'center' });

                // Calculate grid dimensions
                const grid = currentCrossword.grid;
                const rows = grid.length;
                const cols = grid[0].length;
                
                // Fixed space for clues at VERY BOTTOM (45mm)
                const cluesHeight = 45;
                
                // MAXIMIZE grid space - use almost all available space
                const availableWidth = pageWidth - 2 * margin;
                const maxGridHeight = pageHeight - margin - 28 - cluesHeight - 5; // ~175mm for grid!
                
                const cellSizeByWidth = availableWidth / cols;
                const cellSizeByHeight = maxGridHeight / rows;
                const cellSize = Math.min(cellSizeByWidth, cellSizeByHeight, 15); // Increased from 10 to 15!
                
                const gridWidth = cellSize * cols;
                const gridHeight = cellSize * rows;
                const gridX = (pageWidth - gridWidth) / 2;
                const gridY = margin + 22;

                // Draw grid with all cells visible
                doc.setLineWidth(0.4);
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const x = gridX + j * cellSize;
                        const y = gridY + i * cellSize;
                        const cell = grid[i][j];

                        if (cell.letter === null) {
                            // Empty cell - no border, just white space
                            continue;
                        } else {
                            // Draw cell with border
                            doc.setFillColor(255, 255, 255);
                            doc.setDrawColor(80, 80, 80);
                            doc.rect(x, y, cellSize, cellSize, 'FD');
                            
                            // Number (only if NOT showing answers)
                            if (cell.number && !withAnswers) {
                                doc.setFontSize(cellSize * 1.3); // Reduced from 1.5
                                doc.setFont(undefined, 'bold');
                                doc.setTextColor(102, 126, 234);
                                doc.text(cell.number.toString(), x + cellSize * 0.18, y + cellSize * 0.42); // More spacing from edge
                            }

                            // Letter (if with answers)
                            if (withAnswers && cell.letter) {
                                doc.setFontSize(cellSize * 2.5); // Reduced from 2.8 for better centering
                                doc.setFont(undefined, 'bold');
                                doc.setTextColor(0, 0, 0);
                                doc.text(cell.letter, x + cellSize / 2, y + cellSize * 0.65, { align: 'center' }); // Better vertical centering
                            }
                        }
                    }
                }

                // Clues at VERY BOTTOM of page - compact
                const cluesY = pageHeight - cluesHeight - margin + 2;
                const columnWidth = (pageWidth - 2 * margin - 5) / 2;

                doc.setTextColor(0, 0, 0);
                doc.setFontSize(9.5); // Slightly reduced
                doc.setFont(undefined, 'bold');
                doc.text('Horizontal', margin, cluesY);
                doc.text('Vertical', margin + columnWidth + 5, cluesY);

                doc.setFontSize(7.2); // Slightly reduced
                doc.setFont(undefined, 'normal');

                let acrossY = cluesY + 4.5;
                let downY = cluesY + 4.5;
                const lineHeight = 4.0; // Slightly reduced to fit better at bottom
                const maxClueWidth = columnWidth - 2;

                // Horizontal clues
                currentCrossword.across.forEach(word => {
                    const clueText = `${word.number}. ${word.clue}`;
                    const lines = doc.splitTextToSize(clueText, maxClueWidth);
                    
                    if (acrossY + lines.length * lineHeight < pageHeight - margin) {
                        doc.text(lines, margin, acrossY);
                        acrossY += lines.length * lineHeight;
                    }
                });

                // Vertical clues
                currentCrossword.down.forEach(word => {
                    const clueText = `${word.number}. ${word.clue}`;
                    const lines = doc.splitTextToSize(clueText, maxClueWidth);
                    
                    if (downY + lines.length * lineHeight < pageHeight - margin) {
                        doc.text(lines, margin + columnWidth + 5, downY);
                        downY += lines.length * lineHeight;
                    }
                });

                // Save
                const filename = withAnswers ? 
                    `${currentCrossword.title}_corrige.pdf` : 
                    `${currentCrossword.title}.pdf`;
                doc.save(filename);

                showMessage(`‚úÖ PDF t√©l√©charg√©: ${filename}`, "success");
            } catch (error) {
                showMessage("Erreur lors de la cr√©ation du PDF: " + error.message);
                console.error(error);
            }
        }

        function downloadPDFWithAnswers() {
            downloadPDF(true);
        }

        function downloadPNG() {
            if (!currentCrossword) {
                showMessage("Veuillez d'abord g√©n√©rer des mots entrecrois√©s!");
                return;
            }

            try {
                // Letter size at 300 DPI: 8.5" x 11" = 2550px x 3300px
                const canvas = document.createElement('canvas');
                const width = 2550;
                const height = 3300;
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // White background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);

                const margin = 100;

                // Title at top
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(currentCrossword.title, width / 2, margin + 80);

                // Calculate grid dimensions
                const grid = currentCrossword.grid;
                const rows = grid.length;
                const cols = grid[0].length;

                // Compact space for clues at VERY BOTTOM (650px)
                const cluesHeight = 650;
                
                // MAXIMIZE grid space even more!
                const availableWidth = width - 2 * margin;
                const maxGridHeight = height - margin - 200 - cluesHeight - 50; // ~2200px for grid!
                
                const cellSizeByWidth = availableWidth / cols;
                const cellSizeByHeight = maxGridHeight / rows;
                const cellSize = Math.min(cellSizeByWidth, cellSizeByHeight, 150);
                
                const gridWidth = cellSize * cols;
                const gridHeight = cellSize * rows;
                const gridX = (width - gridWidth) / 2;
                const gridY = margin + 180;

                // Draw grid - only cells with letters
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#666666';

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const x = gridX + j * cellSize;
                        const y = gridY + i * cellSize;
                        const cell = grid[i][j];

                        if (cell.letter !== null) {
                            // Draw cell border
                            ctx.strokeRect(x, y, cellSize, cellSize);
                            
                            // Draw number
                            if (cell.number) {
                                ctx.fillStyle = '#667eea';
                                ctx.font = `bold ${cellSize * 0.28}px Arial`;
                                ctx.textAlign = 'left';
                                ctx.fillText(cell.number.toString(), x + cellSize * 0.12, y + cellSize * 0.32);
                            }
                        }
                    }
                }

                // Draw clues at VERY BOTTOM of page
                const cluesY = height - cluesHeight - margin + 20; // Closer to bottom
                const columnWidth = (width - 2 * margin - 60) / 2;

                // Titles
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 44px Arial'; // Slightly reduced
                ctx.textAlign = 'left';
                ctx.fillText('Horizontal', margin, cluesY);
                ctx.fillText('Vertical', margin + columnWidth + 60, cluesY);

                // Clues text
                ctx.font = '30px Arial'; // Slightly reduced
                let acrossY = cluesY + 45;
                let downY = cluesY + 45;
                const lineHeight = 44; // Slightly reduced for compactness

                // Helper function to wrap text
                function wrapText(text, maxWidth) {
                    const words = text.split(' ');
                    const lines = [];
                    let currentLine = words[0];

                    for (let i = 1; i < words.length; i++) {
                        const testLine = currentLine + ' ' + words[i];
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth) {
                            lines.push(currentLine);
                            currentLine = words[i];
                        } else {
                            currentLine = testLine;
                        }
                    }
                    lines.push(currentLine);
                    return lines;
                }

                // Horizontal clues
                currentCrossword.across.forEach(word => {
                    const clueText = `${word.number}. ${word.clue}`;
                    const lines = wrapText(clueText, columnWidth - 20);
                    
                    if (acrossY + lines.length * lineHeight < height - margin) {
                        lines.forEach(line => {
                            ctx.fillText(line, margin, acrossY);
                            acrossY += lineHeight;
                        });
                    }
                });

                // Vertical clues
                currentCrossword.down.forEach(word => {
                    const clueText = `${word.number}. ${word.clue}`;
                    const lines = wrapText(clueText, columnWidth - 20);
                    
                    if (downY + lines.length * lineHeight < height - margin) {
                        lines.forEach(line => {
                            ctx.fillText(line, margin + columnWidth + 60, downY);
                            downY += lineHeight;
                        });
                    }
                });

                // Convert to PNG and download
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${currentCrossword.title}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showMessage(`‚úÖ PNG t√©l√©charg√©: ${currentCrossword.title}.png`, "success");
                }, 'image/png');

            } catch (error) {
                showMessage("Erreur lors de la cr√©ation du PNG: " + error.message);
                console.error(error);
            }
        }
    </script>
</body>
</html>
